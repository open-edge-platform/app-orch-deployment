// Package restClient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version (devel) DO NOT EDIT.
package restClient

import (
	"encoding/json"
	"fmt"
	"time"
)

// Defines values for ConnectProtocolVersion.
const (
	N1 ConnectProtocolVersion = 1
)

// Defines values for ConnectErrorCode.
const (
	Aborted            ConnectErrorCode = "aborted"
	AlreadyExists      ConnectErrorCode = "already_exists"
	Canceled           ConnectErrorCode = "canceled"
	DataLoss           ConnectErrorCode = "data_loss"
	DeadlineExceeded   ConnectErrorCode = "deadline_exceeded"
	FailedPrecondition ConnectErrorCode = "failed_precondition"
	Internal           ConnectErrorCode = "internal"
	InvalidArgument    ConnectErrorCode = "invalid_argument"
	NotFound           ConnectErrorCode = "not_found"
	OutOfRange         ConnectErrorCode = "out_of_range"
	PermissionDenied   ConnectErrorCode = "permission_denied"
	ResourceExhausted  ConnectErrorCode = "resource_exhausted"
	Unauthenticated    ConnectErrorCode = "unauthenticated"
	Unavailable        ConnectErrorCode = "unavailable"
	Unimplemented      ConnectErrorCode = "unimplemented"
	Unknown            ConnectErrorCode = "unknown"
)

// Defines values for DeploymentV1DeleteType.
const (
	ALL        DeploymentV1DeleteType = "ALL"
	PARENTONLY DeploymentV1DeleteType = "PARENT_ONLY"
)

// Defines values for DeploymentV1State.
const (
	DEPLOYING        DeploymentV1State = "DEPLOYING"
	DOWN             DeploymentV1State = "DOWN"
	ERROR            DeploymentV1State = "ERROR"
	INTERNALERROR    DeploymentV1State = "INTERNAL_ERROR"
	NOTARGETCLUSTERS DeploymentV1State = "NO_TARGET_CLUSTERS"
	RUNNING          DeploymentV1State = "RUNNING"
	TERMINATING      DeploymentV1State = "TERMINATING"
	UNKNOWN          DeploymentV1State = "UNKNOWN"
	UPDATING         DeploymentV1State = "UPDATING"
)

// Define the version of the Connect protocol
type ConnectProtocolVersion float32

// Define the timeout, in ms
type ConnectTimeoutHeader = float32

// Error type returned by Connect: https://connectrpc.com/docs/go/errors/#http-representation
type ConnectError struct {
	// The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
	Code *ConnectErrorCode `json:"code,omitempty"`

	// A list of messages that carry the error details. There is no limit on the number of messages.
	Details *[]ConnectErrorDetailsAny `json:"details,omitempty"`

	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
	Message              *string                `json:"message,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
type ConnectErrorCode string

// Contains an arbitrary serialized message along with a @type that describes the type of the serialized message, with an additional debug field for ConnectRPC error details.
type ConnectErrorDetailsAny struct {
	// Detailed error information.
	Debug *ConnectErrorDetailsAny_Debug `json:"debug,omitempty"`

	// A URL that acts as a globally unique identifier for the type of the serialized message. For example: `type.googleapis.com/google.rpc.ErrorInfo`. This is used to determine the schema of the data in the `value` field and is the discriminator for the `debug` field.
	Type *string `json:"type,omitempty"`

	// The Protobuf message, serialized as bytes and base64-encoded. The specific message type is identified by the `type` field.
	Value                *string                `json:"value,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Detailed error information.
type ConnectErrorDetailsAny_Debug struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Details of application.
type DeploymentV1App struct {
	// Id of the app (same as Fleet bundle name) which is,
	//  concatenated from name and deploy_id (uid which comes from k8s).
	Id *string `json:"id,omitempty"`

	// The deployment package app name.
	Name *string `json:"name,omitempty"`

	// Status has details of the deployment.
	Status *DeploymentV1DeploymentStatus `json:"status,omitempty"`
}

// Details of cluster.
type DeploymentV1Cluster struct {
	// Apps has per-app details.
	Apps *[]DeploymentV1App `json:"apps,omitempty"`

	// ID is the cluster id which ECM generates and assigns to the Rancher cluster name.
	Id *string `json:"id,omitempty"`

	// Name is the display name which user provides and ECM creates and assigns clustername label to Fleet cluster object.
	Name *string `json:"name,omitempty"`

	// Status has details of the deployment.
	Status *DeploymentV1DeploymentStatus `json:"status,omitempty"`
}

// Cluster defines the message for the Cluster object.
type DeploymentV1ClusterInfo struct {
	// A Timestamp represents a point in time independent of any time zone or local
	//  calendar, encoded as a count of seconds and fractions of seconds at
	//  nanosecond resolution. The count is relative to an epoch at UTC midnight on
	//  January 1, 1970, in the proleptic Gregorian calendar which extends the
	//  Gregorian calendar backwards to year one.
	//
	//  All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
	//  second table is needed for interpretation, using a [24-hour linear
	//  smear](https://developers.google.com/time/smear).
	//
	//  The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
	//  restricting to that range, we ensure that we can convert to and from [RFC
	//  3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
	//
	//  # Examples
	//
	//  Example 1: Compute Timestamp from POSIX `time()`.
	//
	//      Timestamp timestamp;
	//      timestamp.set_seconds(time(NULL));
	//      timestamp.set_nanos(0);
	//
	//  Example 2: Compute Timestamp from POSIX `gettimeofday()`.
	//
	//      struct timeval tv;
	//      gettimeofday(&tv, NULL);
	//
	//      Timestamp timestamp;
	//      timestamp.set_seconds(tv.tv_sec);
	//      timestamp.set_nanos(tv.tv_usec * 1000);
	//
	//  Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
	//
	//      FILETIME ft;
	//      GetSystemTimeAsFileTime(&ft);
	//      UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
	//
	//      // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
	//      // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
	//      Timestamp timestamp;
	//      timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
	//      timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
	//
	//  Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
	//
	//      long millis = System.currentTimeMillis();
	//
	//      Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
	//          .setNanos((int) ((millis % 1000) * 1000000)).build();
	//
	//  Example 5: Compute Timestamp from Java `Instant.now()`.
	//
	//      Instant now = Instant.now();
	//
	//      Timestamp timestamp =
	//          Timestamp.newBuilder().setSeconds(now.getEpochSecond())
	//              .setNanos(now.getNano()).build();
	//
	//  Example 6: Compute Timestamp from current time in Python.
	//
	//      timestamp = Timestamp()
	//      timestamp.GetCurrentTime()
	//
	//  # JSON Mapping
	//
	//  In JSON format, the Timestamp type is encoded as a string in the
	//  [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
	//  format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
	//  where {year} is always expressed using four digits while {month}, {day},
	//  {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
	//  seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
	//  are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
	//  is required. A proto3 JSON serializer should always use UTC (as indicated by
	//  "Z") when printing the Timestamp type and a proto3 JSON parser should be
	//  able to accept both UTC and other timezones (as indicated by an offset).
	//
	//  For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
	//  01:30 UTC on January 15, 2017.
	//
	//  In JavaScript, one can convert a Date object to this format using the
	//  standard
	//  [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
	//  method. In Python, a standard `datetime.datetime` object can be converted
	//  to this format using
	//  [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
	//  the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
	//  the Joda Time's [`ISODateTimeFormat.dateTime()`](
	//  http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
	//  ) to obtain a formatter capable of generating timestamps in this format.
	CreateTime *GoogleProtobufTimestamp `json:"createTime,omitempty"`

	// ID is the cluster id which ECM generates and assigns to the Rancher cluster name.
	Id *string `json:"id,omitempty"`

	// List of cluster labels retrieved from Fleet cluster object.
	Labels *DeploymentV1ClusterInfo_Labels `json:"labels,omitempty"`

	// Name is the display name which user provides and ECM creates and assigns clustername label to Fleet cluster object.
	Name *string `json:"name,omitempty"`
}

// List of cluster labels retrieved from Fleet cluster object.
type DeploymentV1ClusterInfo_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Response message for the CreateDeployment method.
type DeploymentV1CreateDeploymentResponse struct {
	// Returns the new Deployment Id.
	// string.max_len = 40
	// string.min_len = 1
	DeploymentId string `json:"deploymentId"`
}

// Different delete types to handle parent and child
//
//	lists, for dependency support. Available options: PARENT_ONLY, ALL.
type DeploymentV1DeleteType string

// Deployment defines the specification to deploy a Deployment Package onto a set of clusters.
type DeploymentV1Deployment struct {
	// Set target clusters based on labels.
	AllAppTargetClusters *DeploymentV1TargetClusters `json:"allAppTargetClusters,omitempty"`

	// The deployment package name to deploy from the catalog.
	// string.max_len = 40
	// string.min_len = 1
	// string.pattern = "^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$"
	AppName string `json:"appName"`

	// The version of the deployment package.
	// string.max_len = 20
	// string.min_len = 1
	// string.pattern = "^[a-z0-9][a-z0-9-.]{0,18}[a-z0-9]{0,1}$"
	AppVersion string `json:"appVersion"`

	// Application details.
	Apps *[]DeploymentV1App `json:"apps,omitempty"`

	// A Timestamp represents a point in time independent of any time zone or local
	//  calendar, encoded as a count of seconds and fractions of seconds at
	//  nanosecond resolution. The count is relative to an epoch at UTC midnight on
	//  January 1, 1970, in the proleptic Gregorian calendar which extends the
	//  Gregorian calendar backwards to year one.
	//
	//  All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
	//  second table is needed for interpretation, using a [24-hour linear
	//  smear](https://developers.google.com/time/smear).
	//
	//  The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
	//  restricting to that range, we ensure that we can convert to and from [RFC
	//  3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
	//
	//  # Examples
	//
	//  Example 1: Compute Timestamp from POSIX `time()`.
	//
	//      Timestamp timestamp;
	//      timestamp.set_seconds(time(NULL));
	//      timestamp.set_nanos(0);
	//
	//  Example 2: Compute Timestamp from POSIX `gettimeofday()`.
	//
	//      struct timeval tv;
	//      gettimeofday(&tv, NULL);
	//
	//      Timestamp timestamp;
	//      timestamp.set_seconds(tv.tv_sec);
	//      timestamp.set_nanos(tv.tv_usec * 1000);
	//
	//  Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
	//
	//      FILETIME ft;
	//      GetSystemTimeAsFileTime(&ft);
	//      UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
	//
	//      // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
	//      // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
	//      Timestamp timestamp;
	//      timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
	//      timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
	//
	//  Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
	//
	//      long millis = System.currentTimeMillis();
	//
	//      Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
	//          .setNanos((int) ((millis % 1000) * 1000000)).build();
	//
	//  Example 5: Compute Timestamp from Java `Instant.now()`.
	//
	//      Instant now = Instant.now();
	//
	//      Timestamp timestamp =
	//          Timestamp.newBuilder().setSeconds(now.getEpochSecond())
	//              .setNanos(now.getNano()).build();
	//
	//  Example 6: Compute Timestamp from current time in Python.
	//
	//      timestamp = Timestamp()
	//      timestamp.GetCurrentTime()
	//
	//  # JSON Mapping
	//
	//  In JSON format, the Timestamp type is encoded as a string in the
	//  [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
	//  format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
	//  where {year} is always expressed using four digits while {month}, {day},
	//  {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
	//  seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
	//  are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
	//  is required. A proto3 JSON serializer should always use UTC (as indicated by
	//  "Z") when printing the Timestamp type and a proto3 JSON parser should be
	//  able to accept both UTC and other timezones (as indicated by an offset).
	//
	//  For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
	//  01:30 UTC on January 15, 2017.
	//
	//  In JavaScript, one can convert a Date object to this format using the
	//  standard
	//  [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
	//  method. In Python, a standard `datetime.datetime` object can be converted
	//  to this format using
	//  [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
	//  the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
	//  the Joda Time's [`ISODateTimeFormat.dateTime()`](
	//  http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
	//  ) to obtain a formatter capable of generating timestamps in this format.
	CreateTime *GoogleProtobufTimestamp `json:"createTime,omitempty"`

	// The id of the deployment.
	DeployId *string `json:"deployId,omitempty"`

	// (OPTIONAL) The deployment type for the target cluster deployment can be either auto-scaling or targeted.
	//  In Auto-scaling type, the application will be automatically deployed on all the
	//  clusters which match the Target cluster label. In Targeted type, the user has to select among pre created
	//  clusters to deploy the application.
	// string.max_len = 20
	// string.min_len = 0
	// string.pattern = "^[a-z0-9]*[a-z0-9-]{0,18}[a-z0-9]{0,1}$"
	DeploymentType *string `json:"deploymentType,omitempty"`

	// (OPTIONAL) Deployment display name.
	// string.max_len = 40
	// string.min_len = 0
	// string.pattern = "^([a-zA-Z0-9][\\w\\- \\.\\/_]{0,38}[a-zA-Z0-9]{0,1}|)$"
	DisplayName *string `json:"displayName,omitempty"`

	// Deployment name (unique string assigned by Orchestrator).
	Name *string `json:"name,omitempty"`

	// (OPTIONAL) network_name is the name of the interconnect network that deployment be part of
	// string.max_len = 40
	// string.min_len = 0
	// string.pattern = "^[a-z0-9]*[a-z0-9-]{0,18}[a-z0-9]{0,1}$"
	NetworkName *string `json:"networkName,omitempty"`

	// (OPTIONAL) The Override values can be used to override any of the base profile values based on Deployment scenario.
	OverrideValues *[]DeploymentV1OverrideValues `json:"overrideValues,omitempty"`

	// (OPTIONAL) The selected profile name to be used for the base Helm values of the different applications in the deployment package
	// string.max_len = 40
	// string.min_len = 0
	// string.pattern = "^[a-z0-9]*[a-z0-9-]{0,38}[a-z0-9]{0,1}$"
	ProfileName *string `json:"profileName,omitempty"`

	// (OPTIONAL)
	ServiceExports *[]DeploymentV1ServiceExport `json:"serviceExports,omitempty"`

	// Status has details of the deployment.
	Status *DeploymentV1DeploymentStatus `json:"status,omitempty"`

	// (OPTIONAL) Cluster labels on which we want to deploy the application.
	TargetClusters *[]DeploymentV1TargetClusters `json:"targetClusters,omitempty"`
}

// Status has details of the deployment.
type DeploymentV1DeploymentStatus struct {
	Message *string `json:"message,omitempty"`

	// State are the different states a deployment/cluster/app can be in.
	State *DeploymentV1State `json:"state,omitempty"`

	// Count of status.
	Summary *DeploymentV1Summary `json:"summary,omitempty"`
}

// DeploymentV1DeploymentInstancesCluster defines model for deployment.v1.DeploymentInstancesCluster.
type DeploymentV1DeploymentInstancesCluster struct {
	// Apps has per-app details.
	Apps *[]DeploymentV1App `json:"apps,omitempty"`

	// (OPTIONAL) Deployment display name.
	// string.max_len = 40
	// string.min_len = 0
	// string.pattern = "^([a-zA-Z0-9][\\w\\- \\.\\/_]{0,38}[a-zA-Z0-9]{0,1}|)$"
	DeploymentDisplayName *string `json:"deploymentDisplayName,omitempty"`

	// Deployment name (unique string assigned by Orchestrator).
	DeploymentName *string `json:"deploymentName,omitempty"`

	// Deployment CR UID.
	DeploymentUid *string `json:"deploymentUid,omitempty"`

	// Status has details of the deployment.
	Status *DeploymentV1DeploymentStatus `json:"status,omitempty"`
}

// Request message for the GetappNamespace method.
type DeploymentV1GetAppNamespaceRequest struct {
	// string.max_len = 80
	// string.min_len = 1
	// string.pattern = "^[a-z0-9][a-z0-9-]{0,78}[a-z0-9]{0,1}$"
	AppId string `json:"appId"`
}

// Response message for the GetappNamespace method.
type DeploymentV1GetAppNamespaceResponse struct {
	Namespace string `json:"namespace"`
}

// Response message for GetCluster method.
type DeploymentV1GetClusterResponse struct {
	// Details of cluster.
	Cluster *DeploymentV1Cluster `json:"cluster,omitempty"`
}

// Response message for the GetDeployment method.
type DeploymentV1GetDeploymentResponse struct {
	// Deployment defines the specification to deploy a Deployment Package onto a set of clusters.
	Deployment DeploymentV1Deployment `json:"deployment"`
}

// Response message for the GetDeploymentsStatus method.
type DeploymentV1GetDeploymentsStatusResponse struct {
	// int32.gte = 0
	// int32.gte_lt = 0
	// int32.gte_lt_exclusive = 0
	// int32.gte_lte = 0
	// int32.gte_lte_exclusive = 0
	Deploying *int32 `json:"deploying,omitempty"`

	// int32.gte = 0
	// int32.gte_lt = 0
	// int32.gte_lt_exclusive = 0
	// int32.gte_lte = 0
	// int32.gte_lte_exclusive = 0
	Down *int32 `json:"down,omitempty"`

	// int32.gte = 0
	// int32.gte_lt = 0
	// int32.gte_lt_exclusive = 0
	// int32.gte_lte = 0
	// int32.gte_lte_exclusive = 0
	Error *int32 `json:"error,omitempty"`

	// int32.gte = 0
	// int32.gte_lt = 0
	// int32.gte_lt_exclusive = 0
	// int32.gte_lte = 0
	// int32.gte_lte_exclusive = 0
	Running *int32 `json:"running,omitempty"`

	// int32.gte = 0
	// int32.gte_lt = 0
	// int32.gte_lt_exclusive = 0
	// int32.gte_lte = 0
	// int32.gte_lte_exclusive = 0
	Terminating *int32 `json:"terminating,omitempty"`

	// int32.gte = 0
	// int32.gte_lt = 0
	// int32.gte_lt_exclusive = 0
	// int32.gte_lte = 0
	// int32.gte_lte_exclusive = 0
	Total *int32 `json:"total,omitempty"`

	// int32.gte = 0
	// int32.gte_lt = 0
	// int32.gte_lt_exclusive = 0
	// int32.gte_lte = 0
	// int32.gte_lte_exclusive = 0
	Unknown *int32 `json:"unknown,omitempty"`

	// int32.gte = 0
	// int32.gte_lt = 0
	// int32.gte_lt_exclusive = 0
	// int32.gte_lte = 0
	// int32.gte_lte_exclusive = 0
	Updating *int32 `json:"updating,omitempty"`
}

// Request message for Get KubeConfig method
type DeploymentV1GetKubeConfigRequest struct {
	// Required. The cluster id for the kubeconfig.
	// string.max_len = 40
	// string.min_len = 1
	// string.pattern = "^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$"
	ClusterId string `json:"clusterId"`
}

// Response message for Get KubeConfig method
type DeploymentV1GetKubeConfigResponse struct {
	KubeConfigInfo *DeploymentV1KubeConfigInfo `json:"kubeConfigInfo,omitempty"`
}

// DeploymentV1KubeConfigInfo defines model for deployment.v1.KubeConfigInfo.
type DeploymentV1KubeConfigInfo struct {
	KubeConfig *[]byte `json:"kubeConfig,omitempty"`
}

// Response message for the ListClusters method.
type DeploymentV1ListClustersResponse struct {
	// A list of Cluster Objects.
	Clusters      []DeploymentV1ClusterInfo `json:"clusters"`
	TotalElements int32                     `json:"totalElements"`
}

// Response message for ListDeploymentClusters method.
type DeploymentV1ListDeploymentClustersResponse struct {
	Clusters      []DeploymentV1Cluster `json:"clusters"`
	TotalElements int32                 `json:"totalElements"`
}

// Response message for the ListDeploymentsPerCluster method.
type DeploymentV1ListDeploymentsPerClusterResponse struct {
	// A list of Deployment Instance Cluster Objects.
	DeploymentInstancesCluster []DeploymentV1DeploymentInstancesCluster `json:"deploymentInstancesCluster"`
	TotalElements              int32                                    `json:"totalElements"`
}

// Response message for the ListDeployments method.
type DeploymentV1ListDeploymentsResponse struct {
	// A list of Deployment Objects.
	Deployments   []DeploymentV1Deployment `json:"deployments"`
	TotalElements int32                    `json:"totalElements"`
}

// The Override values can be used to override any of the base helm values of
//
//	applications based on Deployment scenario.
type DeploymentV1OverrideValues struct {
	// deployment package name to use when overriding values.
	// string.max_len = 40
	// string.min_len = 1
	// string.pattern = "^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$"
	AppName string `json:"appName"`

	// (OPTIONAL) The namespace to deploy the app onto, default namespace is default.
	// string.max_len = 63
	// string.min_len = 0
	// string.pattern = "(^$)|^[a-z0-9]([-a-z0-9]{0,61}[a-z0-9])?$"
	TargetNamespace *string `json:"targetNamespace,omitempty"`

	// `Struct` represents a structured data value, consisting of fields
	//  which map to dynamically typed values. In some languages, `Struct`
	//  might be supported by a native representation. For example, in
	//  scripting languages like JS a struct is represented as an
	//  object. The details of that representation are described together
	//  with the proto support for the language.
	//
	//  The JSON representation for `Struct` is JSON object.
	Values *GoogleProtobufStruct `json:"values,omitempty"`
}

// DeploymentV1ServiceExport defines model for deployment.v1.ServiceExport.
type DeploymentV1ServiceExport struct {
	// string.max_len = 40
	// string.min_len = 1
	// string.pattern = "^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$"
	AppName string `json:"appName"`
	Enabled *bool  `json:"enabled,omitempty"`
}

// State are the different states a deployment/cluster/app can be in.
type DeploymentV1State string

// Count of status.
type DeploymentV1Summary struct {
	// Number of down apps/clusters in the deployment.
	Down *int32 `json:"down,omitempty"`

	// Number of running apps/clusters in the deployment, value from owned GitRepo objects.
	Running *int32 `json:"running,omitempty"`

	// Total count of apps/clusters in the deployment, value from owned GitRepo objects.
	Total *int32 `json:"total,omitempty"`

	// Type of thing that we're counting, ie clusters, apps.
	Type *string `json:"type,omitempty"`

	// Unknown status to indicate cluster not reachable.
	Unknown *int32 `json:"unknown,omitempty"`
}

// Set target clusters based on labels.
type DeploymentV1TargetClusters struct {
	// (OPTIONAL) The targeted deployment package name.
	// string.max_len = 40
	// string.min_len = 0
	// string.pattern = "(^$)|^[a-z0-9][a-z0-9-]{0,38}[a-z0-9]{0,1}$"
	AppName *string `json:"appName,omitempty"`

	// (OPTIONAL) Cluster id to match the target cluster when targeted deployment.
	ClusterId *string `json:"clusterId,omitempty"`

	// (OPTIONAL) Cluster labels to match the target cluster when auto-scaling deployment.
	Labels *DeploymentV1TargetClusters_Labels `json:"labels,omitempty"`
}

// (OPTIONAL) Cluster labels to match the target cluster when auto-scaling deployment.
type DeploymentV1TargetClusters_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Response message for the UpdateDeployment method.
type DeploymentV1UpdateDeploymentResponse struct {
	// Deployment defines the specification to deploy a Deployment Package onto a set of clusters.
	Deployment DeploymentV1Deployment `json:"deployment"`
}

// A generic empty message that you can re-use to avoid defining duplicated
//
//	empty messages in your APIs. A typical example is to use it as the request
//	or the response type of an API method. For instance:
//
//	    service Foo {
//	      rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
//	    }
type GoogleProtobufEmpty = map[string]interface{}

// `Struct` represents a structured data value, consisting of fields
//
//	which map to dynamically typed values. In some languages, `Struct`
//	might be supported by a native representation. For example, in
//	scripting languages like JS a struct is represented as an
//	object. The details of that representation are described together
//	with the proto support for the language.
//
//	The JSON representation for `Struct` is JSON object.
type GoogleProtobufStruct struct {
	AdditionalProperties map[string]GoogleProtobufValue `json:"-"`
}

// A Timestamp represents a point in time independent of any time zone or local
//
//	calendar, encoded as a count of seconds and fractions of seconds at
//	nanosecond resolution. The count is relative to an epoch at UTC midnight on
//	January 1, 1970, in the proleptic Gregorian calendar which extends the
//	Gregorian calendar backwards to year one.
//
//	All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
//	second table is needed for interpretation, using a [24-hour linear
//	smear](https://developers.google.com/time/smear).
//
//	The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
//	restricting to that range, we ensure that we can convert to and from [RFC
//	3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
//
//	# Examples
//
//	Example 1: Compute Timestamp from POSIX `time()`.
//
//	    Timestamp timestamp;
//	    timestamp.set_seconds(time(NULL));
//	    timestamp.set_nanos(0);
//
//	Example 2: Compute Timestamp from POSIX `gettimeofday()`.
//
//	    struct timeval tv;
//	    gettimeofday(&tv, NULL);
//
//	    Timestamp timestamp;
//	    timestamp.set_seconds(tv.tv_sec);
//	    timestamp.set_nanos(tv.tv_usec * 1000);
//
//	Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
//
//	    FILETIME ft;
//	    GetSystemTimeAsFileTime(&ft);
//	    UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
//
//	    // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
//	    // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
//	    Timestamp timestamp;
//	    timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
//	    timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
//
//	Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
//
//	    long millis = System.currentTimeMillis();
//
//	    Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
//	        .setNanos((int) ((millis % 1000) * 1000000)).build();
//
//	Example 5: Compute Timestamp from Java `Instant.now()`.
//
//	    Instant now = Instant.now();
//
//	    Timestamp timestamp =
//	        Timestamp.newBuilder().setSeconds(now.getEpochSecond())
//	            .setNanos(now.getNano()).build();
//
//	Example 6: Compute Timestamp from current time in Python.
//
//	    timestamp = Timestamp()
//	    timestamp.GetCurrentTime()
//
//	# JSON Mapping
//
//	In JSON format, the Timestamp type is encoded as a string in the
//	[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
//	format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
//	where {year} is always expressed using four digits while {month}, {day},
//	{hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
//	seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
//	are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
//	is required. A proto3 JSON serializer should always use UTC (as indicated by
//	"Z") when printing the Timestamp type and a proto3 JSON parser should be
//	able to accept both UTC and other timezones (as indicated by an offset).
//
//	For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
//	01:30 UTC on January 15, 2017.
//
//	In JavaScript, one can convert a Date object to this format using the
//	standard
//	[toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
//	method. In Python, a standard `datetime.datetime` object can be converted
//	to this format using
//	[`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
//	the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
//	the Joda Time's [`ISODateTimeFormat.dateTime()`](
//	http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
//	) to obtain a formatter capable of generating timestamps in this format.
type GoogleProtobufTimestamp = time.Time

// `Value` represents a dynamically typed value which can be either
//
//	null, a number, a string, a boolean, a recursive struct value, or a
//	list of values. A producer of value is expected to set one of these
//	variants. Absence of any variant indicates an error.
//
//	The JSON representation for `Value` is JSON value.
type GoogleProtobufValue struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// DeploymentV1ClusterServiceListClustersParams defines parameters for DeploymentV1ClusterServiceListClusters.
type DeploymentV1ClusterServiceListClustersParams struct {
	// Optional. A string array that filters cluster labels to be
	//  displayed ie color=blue,customer=intel. Labels separated by a comma.
	Labels *[]string `form:"labels,omitempty" json:"labels,omitempty"`

	// Optional. Select field and order based on which cluster list will be sorted.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Optional. Selection criteria to list clusters.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Optional. Select count of clusters to be listed per page.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Optional. Offset is used to select the correct page from which clusters list will be displayed.
	//  (E.g If there are 10 clusters, page size is 2 and offset is set as 4, then the response will display clusters 5 and 6).
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// DeploymentV1DeploymentServiceListDeploymentsParams defines parameters for DeploymentV1DeploymentServiceListDeployments.
type DeploymentV1DeploymentServiceListDeploymentsParams struct {
	// Optional. A string array that filters cluster labels to be
	//  displayed ie color=blue,customer=intel-corp. Labels separated by a comma.
	Labels *[]string `form:"labels,omitempty" json:"labels,omitempty"`

	// Optional. Select field and order based on which Deployment list will be sorted.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Optional. Selection criteria to list Deployments.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Optional. Select count of Deployment to be listed per page.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Optional. Offset is used to select the correct page from which Deployment list will be displayed.
	//  (E.g If there are 10 Deployments, page size is 2 and offset is set as 4, then the response will display Deployment 5 and 6.)
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// DeploymentV1DeploymentServiceCreateDeploymentJSONBody defines parameters for DeploymentV1DeploymentServiceCreateDeployment.
type DeploymentV1DeploymentServiceCreateDeploymentJSONBody = DeploymentV1Deployment

// DeploymentV1DeploymentServiceListDeploymentsPerClusterParams defines parameters for DeploymentV1DeploymentServiceListDeploymentsPerCluster.
type DeploymentV1DeploymentServiceListDeploymentsPerClusterParams struct {
	// Optional. A string array that filters cluster labels to be
	//  displayed ie color=blue,customer=intel-corp. Labels separated by a comma.
	Labels *[]string `form:"labels,omitempty" json:"labels,omitempty"`

	// Optional. Select field and order based on which Deployment list will be sorted.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Optional. Selection criteria to list Deployments.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Optional. Select count of Deployment to be listed per page.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Optional. Offset is used to select the correct page from which Deployment list will be displayed.
	//  (E.g If there are 10 Deployments, page size is 2 and offset is set as 4, then the response will display Deployment 5 and 6.)
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// DeploymentV1DeploymentServiceDeleteDeploymentParams defines parameters for DeploymentV1DeploymentServiceDeleteDeployment.
type DeploymentV1DeploymentServiceDeleteDeploymentParams struct {
	// Required. Different delete types to handle parent and child
	//  lists, for dependency support. Available options: PARENT_ONLY, ALL.
	DeleteType DeploymentV1DeleteType `form:"deleteType" json:"deleteType"`
}

// DeploymentV1DeploymentServiceUpdateDeploymentJSONBody defines parameters for DeploymentV1DeploymentServiceUpdateDeployment.
type DeploymentV1DeploymentServiceUpdateDeploymentJSONBody = DeploymentV1Deployment

// DeploymentV1DeploymentServiceListDeploymentClustersParams defines parameters for DeploymentV1DeploymentServiceListDeploymentClusters.
type DeploymentV1DeploymentServiceListDeploymentClustersParams struct {
	// Optional. Select field and order based on which Deployment cluster list will be sorted.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Optional. Selection criteria to list Deployment clusters.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Optional. Select count of Deployment clusters to be listed per page.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Optional. Offset is used to select the correct page from which Deployment clusters list will be displayed.
	//  (E.g If there are 10 Deployment clusters, page size is 2 and offset is set as 4, then the response will display Deployment clusters 5 and 6.)
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// DeploymentV1DeploymentServiceGetDeploymentsStatusParams defines parameters for DeploymentV1DeploymentServiceGetDeploymentsStatus.
type DeploymentV1DeploymentServiceGetDeploymentsStatusParams struct {
	// Optional. A string array that filters cluster labels to be
	//  displayed ie color=blue,customer=intel-corp. Labels separated by a comma.
	Labels *[]string `form:"labels,omitempty" json:"labels,omitempty"`
}

// DeploymentV1ClusterServiceGetKubeConfigJSONBody defines parameters for DeploymentV1ClusterServiceGetKubeConfig.
type DeploymentV1ClusterServiceGetKubeConfigJSONBody = DeploymentV1GetKubeConfigRequest

// DeploymentV1ClusterServiceGetKubeConfigParams defines parameters for DeploymentV1ClusterServiceGetKubeConfig.
type DeploymentV1ClusterServiceGetKubeConfigParams struct {
	ConnectProtocolVersion ConnectProtocolVersion `json:"Connect-Protocol-Version"`
	ConnectTimeoutMs       *ConnectTimeoutHeader  `json:"Connect-Timeout-Ms,omitempty"`
}

// DeploymentV1DeploymentServiceGetAppNamespaceJSONBody defines parameters for DeploymentV1DeploymentServiceGetAppNamespace.
type DeploymentV1DeploymentServiceGetAppNamespaceJSONBody = DeploymentV1GetAppNamespaceRequest

// DeploymentV1DeploymentServiceGetAppNamespaceParams defines parameters for DeploymentV1DeploymentServiceGetAppNamespace.
type DeploymentV1DeploymentServiceGetAppNamespaceParams struct {
	ConnectProtocolVersion ConnectProtocolVersion `json:"Connect-Protocol-Version"`
	ConnectTimeoutMs       *ConnectTimeoutHeader  `json:"Connect-Timeout-Ms,omitempty"`
}

// DeploymentV1DeploymentServiceCreateDeploymentJSONRequestBody defines body for DeploymentV1DeploymentServiceCreateDeployment for application/json ContentType.
type DeploymentV1DeploymentServiceCreateDeploymentJSONRequestBody = DeploymentV1DeploymentServiceCreateDeploymentJSONBody

// DeploymentV1DeploymentServiceUpdateDeploymentJSONRequestBody defines body for DeploymentV1DeploymentServiceUpdateDeployment for application/json ContentType.
type DeploymentV1DeploymentServiceUpdateDeploymentJSONRequestBody = DeploymentV1DeploymentServiceUpdateDeploymentJSONBody

// DeploymentV1ClusterServiceGetKubeConfigJSONRequestBody defines body for DeploymentV1ClusterServiceGetKubeConfig for application/json ContentType.
type DeploymentV1ClusterServiceGetKubeConfigJSONRequestBody = DeploymentV1ClusterServiceGetKubeConfigJSONBody

// DeploymentV1DeploymentServiceGetAppNamespaceJSONRequestBody defines body for DeploymentV1DeploymentServiceGetAppNamespace for application/json ContentType.
type DeploymentV1DeploymentServiceGetAppNamespaceJSONRequestBody = DeploymentV1DeploymentServiceGetAppNamespaceJSONBody

// Getter for additional properties for ConnectError. Returns the specified
// element and whether it was found
func (a ConnectError) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConnectError
func (a *ConnectError) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConnectError to handle AdditionalProperties
func (a *ConnectError) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["code"]; found {
		err = json.Unmarshal(raw, &a.Code)
		if err != nil {
			return fmt.Errorf("error reading 'code': %w", err)
		}
		delete(object, "code")
	}

	if raw, found := object["details"]; found {
		err = json.Unmarshal(raw, &a.Details)
		if err != nil {
			return fmt.Errorf("error reading 'details': %w", err)
		}
		delete(object, "details")
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConnectError to handle AdditionalProperties
func (a ConnectError) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Code != nil {
		object["code"], err = json.Marshal(a.Code)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'code': %w", err)
		}
	}

	if a.Details != nil {
		object["details"], err = json.Marshal(a.Details)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'details': %w", err)
		}
	}

	if a.Message != nil {
		object["message"], err = json.Marshal(a.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ConnectErrorDetailsAny. Returns the specified
// element and whether it was found
func (a ConnectErrorDetailsAny) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConnectErrorDetailsAny
func (a *ConnectErrorDetailsAny) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConnectErrorDetailsAny to handle AdditionalProperties
func (a *ConnectErrorDetailsAny) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["debug"]; found {
		err = json.Unmarshal(raw, &a.Debug)
		if err != nil {
			return fmt.Errorf("error reading 'debug': %w", err)
		}
		delete(object, "debug")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["value"]; found {
		err = json.Unmarshal(raw, &a.Value)
		if err != nil {
			return fmt.Errorf("error reading 'value': %w", err)
		}
		delete(object, "value")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConnectErrorDetailsAny to handle AdditionalProperties
func (a ConnectErrorDetailsAny) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Debug != nil {
		object["debug"], err = json.Marshal(a.Debug)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'debug': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	if a.Value != nil {
		object["value"], err = json.Marshal(a.Value)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'value': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ConnectErrorDetailsAny_Debug. Returns the specified
// element and whether it was found
func (a ConnectErrorDetailsAny_Debug) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConnectErrorDetailsAny_Debug
func (a *ConnectErrorDetailsAny_Debug) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConnectErrorDetailsAny_Debug to handle AdditionalProperties
func (a *ConnectErrorDetailsAny_Debug) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConnectErrorDetailsAny_Debug to handle AdditionalProperties
func (a ConnectErrorDetailsAny_Debug) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DeploymentV1ClusterInfo_Labels. Returns the specified
// element and whether it was found
func (a DeploymentV1ClusterInfo_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DeploymentV1ClusterInfo_Labels
func (a *DeploymentV1ClusterInfo_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DeploymentV1ClusterInfo_Labels to handle AdditionalProperties
func (a *DeploymentV1ClusterInfo_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DeploymentV1ClusterInfo_Labels to handle AdditionalProperties
func (a DeploymentV1ClusterInfo_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DeploymentV1TargetClusters_Labels. Returns the specified
// element and whether it was found
func (a DeploymentV1TargetClusters_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DeploymentV1TargetClusters_Labels
func (a *DeploymentV1TargetClusters_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DeploymentV1TargetClusters_Labels to handle AdditionalProperties
func (a *DeploymentV1TargetClusters_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DeploymentV1TargetClusters_Labels to handle AdditionalProperties
func (a DeploymentV1TargetClusters_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for GoogleProtobufStruct. Returns the specified
// element and whether it was found
func (a GoogleProtobufStruct) Get(fieldName string) (value GoogleProtobufValue, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GoogleProtobufStruct
func (a *GoogleProtobufStruct) Set(fieldName string, value GoogleProtobufValue) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]GoogleProtobufValue)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GoogleProtobufStruct to handle AdditionalProperties
func (a *GoogleProtobufStruct) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]GoogleProtobufValue)
		for fieldName, fieldBuf := range object {
			var fieldVal GoogleProtobufValue
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GoogleProtobufStruct to handle AdditionalProperties
func (a GoogleProtobufStruct) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for GoogleProtobufValue. Returns the specified
// element and whether it was found
func (a GoogleProtobufValue) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GoogleProtobufValue
func (a *GoogleProtobufValue) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GoogleProtobufValue to handle AdditionalProperties
func (a *GoogleProtobufValue) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GoogleProtobufValue to handle AdditionalProperties
func (a GoogleProtobufValue) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
